services:
  garmin-mcp:
    networks:
      - backend_net
    container_name: garmin-mcp-server
    image: "ghcr.io/banzzouille/garmin-mcp-server"

    # Option 1: Use environment variables directly
    environment:
      - GARMIN_EMAIL=${GARMIN_EMAIL}
      - GARMIN_PASSWORD=${GARMIN_PASSWORD}
      # Control transport/mapping from .env or env vars (defaults shown)
      - GARMIN_MCP_TRANSPORT=${GARMIN_MCP_TRANSPORT:-stdio}
      # bind inside container to all interfaces so published port can reach it
      - GARMIN_MCP_HOST=${GARMIN_MCP_HOST:-0.0.0.0}
      - GARMIN_MCP_PORT=${GARMIN_MCP_PORT:-8000}
      - GARMIN_USE_UV=${GARMIN_USE_UV:-false}
      # Optional override to run a custom command (entrypoint.sh will execute it)
      # - GARMIN_RUN_CMD=${GARMIN_RUN_CMD}
      - GARMIN_MCP_BIND=${GARMIN_MCP_BIND:-127.0.0.1}
      # host side port (default changed to 9000)
      - GARMIN_HOST_PORT=${GARMIN_HOST_PORT:-9000}

    # publish host port 9000 -> container port 8000
    ports:
      - "${GARMIN_MCP_BIND:-127.0.0.1}:${GARMIN_HOST_PORT:-9000}:${GARMIN_MCP_PORT:-8000}"

    # Mount volume to persist Garmin OAuth tokens
    volumes:
      - /mnt/user/appdata/garmin-mcp-server:/root/.garminconnect

    # Restart policy
    restart: unless-stopped

    # Optional: Set stdin_open and tty for interactive MFA input
    stdin_open: true
    tty: true

networks:
  backend_net:
    external: true  

# Uncomment if using file-based secrets
# secrets:
#   garmin_email:
#     file: ./secrets/garmin_email.txt
#   garmin_password:
#     file: ./secrets/garmin_password.txt
